<div class="markdown-heading"><h1 class="heading-element">Spring Boot 配置</h1><a id="user-content-springboot-配置" class="anchor" aria-label="Permalink: Spring Boot 配置" href="#springboot-配置"><span aria-hidden="true" class="octicon octicon-link"></span></a></div>
<p>仅列举相关配置, 具体配置时, 还需要根据实际使用的版本环境进行调整.</p>
<div class="markdown-heading"><h3 class="heading-element">Tomcat连接池</h3><a id="user-content-tomcat连接池" class="anchor" aria-label="Permalink: Tomcat连接池" href="#tomcat连接池"><span aria-hidden="true" class="octicon octicon-link"></span></a></div>
<p>默认配置: org\springframework\boot\spring-boot-autoconfigure\2.3.12.RELEASE\spring-boot-autoconfigure-2.3.12.RELEASE.jar\META-INF\spring-configuration-metadata.json</p>
<div class="highlight highlight-source-yaml"><pre><span class="pl-ent">server</span>:
  <span class="pl-ent">tomcat</span>:
    <span class="pl-ent">max-connections</span>: <span class="pl-c1">10000</span>  <span class="pl-c"><span class="pl-c">#</span> 最大连接数 默认:8192</span>
    <span class="pl-ent">threads</span>:
      <span class="pl-ent">max</span>: <span class="pl-c1">800</span>              <span class="pl-c"><span class="pl-c">#</span> 最大工作线程数 默认:200</span>
      <span class="pl-ent">min-spare</span>: <span class="pl-c1">100</span>        <span class="pl-c"><span class="pl-c">#</span> 最小空闲线程数 默认:10</span>
    <span class="pl-ent">accept-count</span>: <span class="pl-c1">100</span>       <span class="pl-c"><span class="pl-c">#</span> 等待队列长度 默认:100</span>
    <span class="pl-ent">connection-timeout</span>: <span class="pl-c1">20000</span> <span class="pl-c"><span class="pl-c">#</span> 默认未配置</span></pre></div>
<div class="markdown-heading"><h3 class="heading-element">数据库连接池</h3><a id="user-content-数据库连接池" class="anchor" aria-label="Permalink: 数据库连接池" href="#数据库连接池"><span aria-hidden="true" class="octicon octicon-link"></span></a></div>
<p>SpringBoot默认使用HikariCP作为数据库连接池</p>
<div class="highlight highlight-source-yaml"><pre><span class="pl-ent">spring</span>:
  <span class="pl-ent">datasource</span>:
    <span class="pl-ent">hikari</span>:
      <span class="pl-ent">maximum-pool-size</span>: <span class="pl-c1">50</span>      <span class="pl-c"><span class="pl-c">#</span> 最大连接数，默认:10</span>
      <span class="pl-ent">minimum-idle</span>: <span class="pl-c1">10</span>           <span class="pl-c"><span class="pl-c">#</span> 最小空闲连接，默认:10</span>
      <span class="pl-ent">connection-timeout</span>: <span class="pl-c1">30000</span>
      <span class="pl-ent">idle-timeout</span>: <span class="pl-c1">600000</span>       <span class="pl-c"><span class="pl-c">#</span> 空闲连接超时时间，默认:600000（10分钟）</span>
      <span class="pl-ent">max-lifetime</span>: <span class="pl-c1">1800000</span>      <span class="pl-c"><span class="pl-c">#</span> 连接最大存活时间 默认:1800000（30分钟）</span>
      <span class="pl-ent">leak-detection-threshold</span>: <span class="pl-c1">60000</span> <span class="pl-c"><span class="pl-c">#</span> 连接泄露检查阈值，默认:0（关闭）</span></pre></div>
<div class="markdown-heading"><h3 class="heading-element">Jackson时区序列化</h3><a id="user-content-jackson时区序列化" class="anchor" aria-label="Permalink: Jackson时区序列化" href="#jackson时区序列化"><span aria-hidden="true" class="octicon octicon-link"></span></a></div>
<p>SpringBoot默认使用Jackson处理JSON序列化，但时区处理经常出问题。</p>
<p>默认情况下，Jackson会使用系统时区，这在分布式部署时会导致不一致的问题。</p>
<div class="highlight highlight-source-yaml"><pre><span class="pl-ent">spring</span>:
  <span class="pl-ent">jackson</span>:
    <span class="pl-ent">time-zone</span>: <span class="pl-s">GMT+8</span>
    <span class="pl-ent">date-format</span>: <span class="pl-s">yyyy-MM-dd HH:mm:ss</span>
    <span class="pl-ent">serialization</span>:
      <span class="pl-ent">write-dates-as-timestamps</span>: <span class="pl-c1">false</span></pre></div>
<div class="markdown-heading"><h3 class="heading-element">日志配置</h3><a id="user-content-日志配置" class="anchor" aria-label="Permalink: 日志配置" href="#日志配置"><span aria-hidden="true" class="octicon octicon-link"></span></a></div>
<p>SpringBoot默认使用Logback，但默认配置下没有对日志文件进行滚动和清理。</p>
<p>长时间运行的应用会产生巨大的日志文件，最终占满磁盘空间。</p>
<div class="highlight highlight-source-yaml"><pre><span class="pl-ent">logging</span>:
  <span class="pl-ent">file</span>:
    <span class="pl-ent">name</span>: <span class="pl-s">app.log</span>
  <span class="pl-ent">logback</span>:
    <span class="pl-ent">rollingpolicy</span>:
      <span class="pl-ent">max-file-size</span>: <span class="pl-s">100MB</span>
      <span class="pl-ent">max-history</span>: <span class="pl-c1">30</span>
      <span class="pl-ent">total-size-cap</span>: <span class="pl-s">3GB</span></pre></div>
<div class="markdown-heading"><h3 class="heading-element">缓存配置</h3><a id="user-content-缓存配置" class="anchor" aria-label="Permalink: 缓存配置" href="#缓存配置"><span aria-hidden="true" class="octicon octicon-link"></span></a></div>
<p>SpringBoot的@Cacheable注解默认使用ConcurrentHashMap作为缓存实现，但这个实现没有过期机制，也没有大小限制。在高并发场景下，缓存会无限增长，最终导致内存溢出。
可以考虑使用Caffeine替代默认实现，可以提供更好的性能和内存管理能力。</p>
<div class="highlight highlight-source-yaml"><pre><span class="pl-ent">spring</span>:
  <span class="pl-ent">cache</span>:
    <span class="pl-ent">type</span>: <span class="pl-s">caffeine</span>
    <span class="pl-ent">caffeine</span>:
      <span class="pl-ent">spec</span>: <span class="pl-s">maximumSize=10000,expireAfterWrite=600s</span></pre></div>
<div class="markdown-heading"><h3 class="heading-element">监控端点</h3><a id="user-content-监控端点" class="anchor" aria-label="Permalink: 监控端点" href="#监控端点"><span aria-hidden="true" class="octicon octicon-link"></span></a></div>
<p>SpringBoot Actuator默认暴露了很多监控端点，包括健康检查、配置信息、环境变量等。</p>
<p>只暴露必要的端点，并且配置适当的安全策略，避免信息泄漏。</p>
<div class="highlight highlight-source-yaml"><pre><span class="pl-ent">management</span>:
  <span class="pl-ent">endpoints</span>:
    <span class="pl-ent">web</span>:
      <span class="pl-ent">exposure</span>:
        <span class="pl-ent">include</span>: <span class="pl-s">health,info,metrics</span>
  <span class="pl-ent">endpoint</span>:
    <span class="pl-ent">health</span>:
      <span class="pl-ent">show-details</span>: <span class="pl-s">when-authorized</span></pre></div>
<div class="markdown-heading"><h3 class="heading-element">文件上传大小限制</h3><a id="user-content-文件上传大小限制" class="anchor" aria-label="Permalink: 文件上传大小限制" href="#文件上传大小限制"><span aria-hidden="true" class="octicon octicon-link"></span></a></div>
<p>SpringBoot默认的文件上传限制非常小，单个文件只能上传1MB，整个请求大小限制10MB。</p>
<div class="highlight highlight-source-yaml"><pre><span class="pl-ent">spring</span>:
  <span class="pl-ent">servlet</span>:
    <span class="pl-ent">multipart</span>:
      <span class="pl-ent">max-file-size</span>: <span class="pl-s">100MB</span>
      <span class="pl-ent">max-request-size</span>: <span class="pl-s">100MB</span>
      <span class="pl-ent">file-size-threshold</span>: <span class="pl-s">2KB</span>
      <span class="pl-ent">location</span>: <span class="pl-s">/tmp</span>
      <span class="pl-ent">resolve-lazily</span>: <span class="pl-c1">false</span></pre></div>
<div class="markdown-heading"><h3 class="heading-element">异步线程池配置</h3><a id="user-content-异步线程池配置" class="anchor" aria-label="Permalink: 异步线程池配置" href="#异步线程池配置"><span aria-hidden="true" class="octicon octicon-link"></span></a></div>
<p>使用<code>@Async</code>注解时，SpringBoot默认使用<code>SimpleAsyncTaskExecutor</code>，这个执行器每次都会创建新线程，没有线程池复用机制。高并发情况下会创建大量线程，最终导致系统资源耗尽。</p>
<div class="highlight highlight-source-yaml"><pre><span class="pl-ent">spring</span>:
  <span class="pl-ent">task</span>:
    <span class="pl-ent">execution</span>:
      <span class="pl-ent">pool</span>:
        <span class="pl-ent">core-size</span>: <span class="pl-c1">8</span>
        <span class="pl-ent">max-size</span>: <span class="pl-c1">16</span>
        <span class="pl-ent">queue-capacity</span>: <span class="pl-c1">100</span>
        <span class="pl-ent">keep-alive</span>: <span class="pl-c1">60s</span>
      <span class="pl-ent">thread-name-prefix</span>: <span class="pl-s">async-task-</span>
    <span class="pl-ent">scheduling</span>:
      <span class="pl-ent">pool</span>:
        <span class="pl-ent">size</span>: <span class="pl-c1">4</span>
      <span class="pl-ent">thread-name-prefix</span>: <span class="pl-s">scheduling-</span></pre></div>
<div class="markdown-heading"><h3 class="heading-element">静态资源缓存策略</h3><a id="user-content-静态资源缓存策略" class="anchor" aria-label="Permalink: 静态资源缓存策略" href="#静态资源缓存策略"><span aria-hidden="true" class="octicon octicon-link"></span></a></div>
<p>SpringBoot默认不为静态资源设置HTTP缓存头，浏览器每次都会重新请求CSS、JS、图片等静态文件，影响页面加载性能。</p>
<div class="highlight highlight-source-yaml"><pre><span class="pl-ent">spring</span>:
  <span class="pl-ent">web</span>:
    <span class="pl-ent">resources</span>:
      <span class="pl-ent">cache</span>:
        <span class="pl-ent">cachecontrol</span>:
          <span class="pl-ent">max-age</span>: <span class="pl-c1">365d</span>
          <span class="pl-ent">cache-public</span>: <span class="pl-c1">true</span>
      <span class="pl-ent">chain</span>:
        <span class="pl-ent">strategy</span>:
          <span class="pl-ent">content</span>:
            <span class="pl-ent">enabled</span>: <span class="pl-c1">true</span>
            <span class="pl-ent">paths</span>: <span class="pl-s">/**</span>
        <span class="pl-ent">cache</span>: <span class="pl-c1">true</span>
      <span class="pl-ent">static-locations</span>: <span class="pl-s">classpath:/static/</span></pre></div>
<p>开启内容版本化策略后，SpringBoot会根据文件内容生成MD5哈希值作为版本号，文件名变成<code>style-abc123.css</code>这样的格式。当文件内容发生变化时，哈希值也会变化，浏览器会认为这是新文件重新下载；如果文件没变化，浏览器就直接使用缓存，有效提升页面加载速度。</p>
<div class="markdown-heading"><h3 class="heading-element">数据库事务超时</h3><a id="user-content-数据库事务超时" class="anchor" aria-label="Permalink: 数据库事务超时" href="#数据库事务超时"><span aria-hidden="true" class="octicon octicon-link"></span></a></div>
<p><code>@Transactional</code>注解默认没有设置超时时间，长时间运行的事务会一直持有数据库锁，影响其他操作的执行。批量数据处理时，容易出现锁表问题。</p>
<div class="highlight highlight-source-java"><pre><span class="pl-c1">@</span><span class="pl-c1">Transactional</span>(<span class="pl-s1">timeout</span> = <span class="pl-c1">30</span>, <span class="pl-s1">rollbackFor</span> = <span class="pl-smi">Exception</span>.<span class="pl-k">class</span>)
<span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">batchProcess</span>(<span class="pl-smi">List</span>&lt;<span class="pl-smi">Data</span>&gt; <span class="pl-s1">dataList</span>) {
    <span class="pl-c">// 分批处理，避免长事务</span>
    <span class="pl-smi">int</span> <span class="pl-s1">batchSize</span> = <span class="pl-c1">100</span>;
    <span class="pl-k">for</span> (<span class="pl-smi">int</span> <span class="pl-s1">i</span> = <span class="pl-c1">0</span>; <span class="pl-s1">i</span> &lt; <span class="pl-s1">dataList</span>.<span class="pl-en">size</span>(); <span class="pl-s1">i</span> += <span class="pl-s1">batchSize</span>) {
        <span class="pl-smi">List</span>&lt;<span class="pl-smi">Data</span>&gt; <span class="pl-s1">batch</span> = <span class="pl-s1">dataList</span>.<span class="pl-en">subList</span>(<span class="pl-s1">i</span>,
            <span class="pl-smi">Math</span>.<span class="pl-en">min</span>(<span class="pl-s1">i</span> + <span class="pl-s1">batchSize</span>, <span class="pl-s1">dataList</span>.<span class="pl-en">size</span>()));
        <span class="pl-en">processBatch</span>(<span class="pl-s1">batch</span>);
    }
}</pre></div>
