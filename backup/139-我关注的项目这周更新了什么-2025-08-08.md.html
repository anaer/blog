
  <article class="markdown-body">
    <h1 id="1-bili-hardcore-v051">1. <a href="https://github.com/Karben233/bili-hardcore/releases/tag/v0.5.1">bili-hardcore v0.5.1</a></h1>
<p>bilibili 硬核会员 AI 自动答题脚本，直接调用 B 站 API，非 OCR 实现  </p>
<p>API请求报错后自动重试的实现方案：  </p>
<ol>
<li>核心机制  </li>
<li>通过捕获异常触发重试逻辑  </li>
<li>设置最大重试次数（通常3-5次）  </li>
<li>
<p>采用指数退避策略（每次重试间隔时间递增）  </p>
</li>
<li>
<p>关键实现步骤<br />
1) 定义重试条件：  </p>
</li>
<li>网络异常（连接超时、响应超时）  </li>
<li>服务端5xx错误  </li>
<li>特定业务错误码  </li>
</ol>
<p>2) 实现重试策略：<br />
   - 固定间隔（简单但可能加剧服务压力）<br />
   - 随机间隔（避免惊群效应）<br />
   - 指数退避（推荐方案）  </p>
<p>3) 终止条件：<br />
   - 达到最大重试次数<br />
   - 遇到不可重试错误（如4xx错误）<br />
   - 收到成功响应  </p>
<ol>
<li>注意事项  </li>
<li>幂等性处理：确保重试不会产生副作用  </li>
<li>重试日志记录：便于问题排查  </li>
<li>熔断机制：避免持续重试导致系统雪崩  </li>
<li>上下文传递：保持请求上下文的一致性  </li>
</ol>
<p>典型实现方式包括使用现成库（如Retry4j、Spring Retry）或自行封装重试逻辑。  </p>
  </article>
  
<script>
document.addEventListener('DOMContentLoaded', () => {
  // 复制功能
  document.querySelectorAll('.copy-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const code = btn.nextElementSibling.querySelector('code').innerText;
      navigator.clipboard.writeText(code).then(() => {
        btn.textContent = '已复制';
        setTimeout(() => btn.textContent = '复制', 1500);
      });
    });
  });

  // 折叠功能
  document.addEventListener('click', e => {
    if (e.target.classList.contains('fold-btn')) {
      const pre = e.target.parentElement.querySelector('pre');
      const collapsed = pre.style.display === 'none';
      pre.style.display = collapsed ? 'block' : 'none';
      e.target.textContent = collapsed ? '收起' : '展开';
    }
  });
});
</script>

